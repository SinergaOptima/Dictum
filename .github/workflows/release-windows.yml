name: Windows Release

on:
  workflow_dispatch:
    inputs:
      release_channel:
        description: "stable publishes as normal release; canary publishes as prerelease"
        required: false
        default: "stable"
        type: choice
        options:
          - stable
          - canary
      publish_as_latest:
        description: "mark release as latest (stable only)"
        required: false
        default: true
        type: boolean
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-latest
    concurrency:
      group: release-windows-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: dictum-ui/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0.0" --locked

      - name: Install UI dependencies
        working-directory: dictum-ui
        run: npm ci

      - name: Build Tauri NSIS bundle
        working-directory: dictum-app
        run: cargo tauri build --bundles nsis

      - name: Locate build artifacts
        id: artifacts
        shell: pwsh
        run: |
          $exe = Resolve-Path "target/release/dictum.exe"
          $installer = Get-ChildItem "target/release/bundle/nsis" -Filter "*-setup.exe" | Select-Object -First 1
          if (-not $installer) {
            throw "NSIS installer not found."
          }
          "exe_path=$($exe.Path)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "installer_path=$($installer.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Resolve release metadata
        id: release_meta
        shell: pwsh
        run: |
          $channel = "stable"
          if ("${{ github.event_name }}" -eq "workflow_dispatch" -and "${{ github.event.inputs.release_channel }}" -eq "canary") {
            $channel = "canary"
          }
          "channel=$channel" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "prerelease=$([bool]($channel -eq 'canary'))" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Sign binaries (required)
        id: sign_step
        shell: pwsh
        env:
          WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERT_BASE64 }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
          WINDOWS_CERT_EXPECTED_SUBJECT: ${{ secrets.WINDOWS_CERT_EXPECTED_SUBJECT }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERT_BASE64) -or [string]::IsNullOrWhiteSpace($env:WINDOWS_CERT_PASSWORD)) {
            throw "Signing secrets are required. Set WINDOWS_CERT_BASE64 and WINDOWS_CERT_PASSWORD."
          }
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERT_EXPECTED_SUBJECT)) {
            $env:WINDOWS_CERT_EXPECTED_SUBJECT = "Lattice Labs"
          }
          $certPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($env:WINDOWS_CERT_BASE64))
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" |
            Where-Object { $_.FullName -match "\\x64\\signtool\.exe$" } |
            Sort-Object FullName -Descending |
            Select-Object -First 1
          if (-not $signtool) {
            throw "signtool.exe not found on runner."
          }
          & $signtool.FullName sign /fd SHA256 /f $certPath /p $env:WINDOWS_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 "${{ steps.artifacts.outputs.exe_path }}"
          if ($LASTEXITCODE -ne 0) { throw "Failed to sign dictum.exe" }
          & $signtool.FullName sign /fd SHA256 /f $certPath /p $env:WINDOWS_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 "${{ steps.artifacts.outputs.installer_path }}"
          if ($LASTEXITCODE -ne 0) { throw "Failed to sign installer" }
          $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
          $cert.Import($certPath, $env:WINDOWS_CERT_PASSWORD, "DefaultKeySet")
          $subject = $cert.Subject
          if ($subject -notmatch [regex]::Escape($env:WINDOWS_CERT_EXPECTED_SUBJECT)) {
            throw "Signing certificate subject '$subject' does not include expected '$($env:WINDOWS_CERT_EXPECTED_SUBJECT)'."
          }
          "signed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Verify Authenticode signatures
        shell: pwsh
        env:
          WINDOWS_CERT_EXPECTED_SUBJECT: ${{ secrets.WINDOWS_CERT_EXPECTED_SUBJECT }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:WINDOWS_CERT_EXPECTED_SUBJECT)) {
            $env:WINDOWS_CERT_EXPECTED_SUBJECT = "Lattice Labs"
          }
          $files = @(
            "${{ steps.artifacts.outputs.exe_path }}",
            "${{ steps.artifacts.outputs.installer_path }}"
          )
          foreach ($file in $files) {
            $sig = Get-AuthenticodeSignature $file
            if ($sig.Status -ne "Valid") {
              throw "Authenticode signature invalid for $file (status=$($sig.Status))"
            }
            $subject = $sig.SignerCertificate.Subject
            if ($subject -notmatch [regex]::Escape($env:WINDOWS_CERT_EXPECTED_SUBJECT)) {
              throw "Signer subject '$subject' does not include expected '$($env:WINDOWS_CERT_EXPECTED_SUBJECT)' for $file."
            }
          }

      - name: Generate SHA256 checksums
        shell: pwsh
        run: |
          $exeHash = (Get-FileHash "${{ steps.artifacts.outputs.exe_path }}" -Algorithm SHA256).Hash
          $installerHash = (Get-FileHash "${{ steps.artifacts.outputs.installer_path }}" -Algorithm SHA256).Hash
          @(
            "dictum.exe  $exeHash"
            "$(Split-Path -Leaf '${{ steps.artifacts.outputs.installer_path }}')  $installerHash"
          ) | Out-File -FilePath "target/release/SHA256SUMS.txt" -Encoding ascii

      - name: Verify checksum file format
        shell: pwsh
        run: |
          $lines = Get-Content "target/release/SHA256SUMS.txt"
          if ($lines.Count -lt 2) { throw "SHA256SUMS.txt is missing required entries" }
          foreach ($line in $lines) {
            if ($line -notmatch "^[^ ]+\s+[A-Fa-f0-9]{64}$") {
              throw "Malformed checksum line: $line"
            }
          }

      - name: Write release manifest
        shell: pwsh
        run: |
          $manifest = @{
            tag = "${{ github.ref_name }}"
            commit = "${{ github.sha }}"
            channel = "${{ steps.release_meta.outputs.channel }}"
            signed = "${{ steps.sign_step.outputs.signed }}"
            generated_at_utc = (Get-Date).ToUniversalTime().ToString("o")
          } | ConvertTo-Json
          $manifest | Out-File -FilePath "target/release/RELEASE_MANIFEST.json" -Encoding utf8

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dictum-windows-release
          path: |
            ${{ steps.artifacts.outputs.exe_path }}
            ${{ steps.artifacts.outputs.installer_path }}
            target/release/SHA256SUMS.txt
            target/release/RELEASE_MANIFEST.json

      - name: Publish GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          prerelease: ${{ steps.release_meta.outputs.prerelease }}
          make_latest: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.publish_as_latest == false && 'false' || 'true' }}
          files: |
            ${{ steps.artifacts.outputs.exe_path }}
            ${{ steps.artifacts.outputs.installer_path }}
            target/release/SHA256SUMS.txt
            target/release/RELEASE_MANIFEST.json
